(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{192:function(s,n,a){const l=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return l.createElement("section",{className:"markdown"},l.createElement("h1",null,"闭包"),l.createElement("p",null,"MDN:函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript，函数在每次创建时生成闭包。 用例子说明："),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">//foo的作用域中声明了局部变量a和函数bar，bar是foo的内部函数，只能在foo内部访问</span>\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">//根据变量在作用域中由内而外的查找过程，bar函数能访问其父函数foo中的局部变量a</span>\n    <span class="hljs-built_in">console</span>.log(a);\n  }\n  bar();\n}\nfoo();\n'}})),l.createElement("p",null,l.createElement("strong",null,"注意：词法（lexical）一词表明，词法作用域根据声明变量的位置来确定该变量可被访问的位置。嵌套函数可获取声明于外部作用域的函数。这跟函数在哪里调用无关")),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <span class="hljs-comment">//在此声明的变量可以被内部函数bar访问</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(a);\n  };\n}\n<span class="hljs-keyword">var</span> f = f1();\nf();\n<span class="hljs-comment">/* 以上例子尽管bar函数被返回，但仍可访问其词法作用域中的局部变量a */</span>\n'}})),l.createElement("h2",null,"循环中的闭包"),l.createElement("p",null,"来看一道经典的面试题："),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">idx</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(idx);\n}\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    test(i);\n  }, <span class="hljs-number">1000</span>);\n}\n'}})),l.createElement("p",null,"该题的输出并不是 0，1，而是 2，2。循环中传递给延时函数的回调函数是同一个引用，共享同一个词法作用域，域中包含局部变量 i，该局部变量被共享，即每次循环后都改变，延时回调之前已经处理完毕，所以连续两次输出最后的 i 值 2。解决这个问题可以有以下两种方法："),l.createElement("ul",null,l.createElement("li",null,"添加一个闭包")),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">idx</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(idx);\n  };\n}\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {\n  <span class="hljs-built_in">setTimeout</span>(test1(i), <span class="hljs-number">1000</span>);\n}\n'}})),l.createElement("p",null,"回调函数是有函数 test 创建并返回的新函数，即每次循环创建了新的词法作用域，局部变量 i 在不同的作用域中不共享，所以不受影响，输出依次为 0，1"),l.createElement("ul",null,l.createElement("li",null,"立即执行函数")),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">idx</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(idx);\n}\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {\n  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>{\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      test(i);\n    }, <span class="hljs-number">1000</span>);\n  })(i);\n}\n'}})),l.createElement("p",null,"JS 中调用函数传递参数都是值传递 ，所以当立即执行函数执行时，首先会把参数 i 的值复制一份，然后再创建函数作用域来执行函数,即 i 不是共享的变量"),l.createElement("h2",null,"总结"),l.createElement("p",null,"当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数时，就产生了闭包。即产生闭包的条件是：1.函数嵌套；2.内部函数引用了外部函数的数据（变量或函数）"))}}}]);
//# sourceMappingURL=31.fbddaac9c9.js.map