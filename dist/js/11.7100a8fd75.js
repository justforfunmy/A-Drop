(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{219:function(s,a,n){const l=n(0);s.exports=function(s){Object.keys(s).forEach((function(a){this[a]=s[a]}));return l.createElement("section",{className:"markdown"},l.createElement("h1",null,"HTML 中超大数据量的渲染性能优化"),l.createElement("p",null,"如果要在 html 中渲染 100000 条数据，我们该怎么做"),l.createElement("h2",null,"一次性渲染"),l.createElement("p",null,"最简单的方法就是一次性添加。"),l.createElement("pre",null,l.createElement("code",{className:"language-html",dangerouslySetInnerHTML:{__html:'<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();\n    <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>;\n    <span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);\n    <span class="hljs-comment">//这里用创建文档片段的方法，已经做了一点优化，尽管效果并不明显</span>\n    <span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) {\n      <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);\n      li.innerText = i;\n      fragment.appendChild(li);\n    }\n    ul.appendChild(fragment);\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;JS运行时间：&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - now);\n    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;总运行时间：&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - now);\n    }, <span class="hljs-number">0</span>);\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n'}})),l.createElement("p",null,"当我们运行 html 时，比较长的一段时间页面空白，然后一次性加载完成；当我们滚动页面时，也会出现空白闪动的现象。"),l.createElement("p",null,"关于计算 js 运行时间和总运行时间，需要了解以下 js 引擎和浏览器渲染进程的知识。这里简单地说一下，就是 js 引擎和渲染引擎是互斥的，不能同时执行，在 Event Loop 中，当 JS 引擎所管理的执行栈中的事件以及所有微任务执行完后，才会触发渲染线程对页面进行渲染。而以上代码中的",l.createElement("code",{dangerouslySetInnerHTML:{__html:"setTimeout"}}),"的回调函数会被加入到下一次的事件循环，在浏览器渲染完成之后执行。关于浏览器进程和线程的，可以参见",l.createElement("a",{href:"https://segmentfault.com/a/1190000012925872"},"从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理"),",这里就不深入了。"),l.createElement("p",null,"经过执行，可以得到 JS 运行时间为 253 毫秒，而总运行时间达 6105 毫秒。同时，我们监控以下",l.createElement("code",{dangerouslySetInnerHTML:{__html:"performance"}}),"，可以得到以下结果："),l.createElement("p",null,l.createElement("img",{src:n(272).default,alt:"一次性渲染"})),l.createElement("p",null,"可以看出，性能瓶颈在渲染阶段，而不是 js 运行。"),l.createElement("h2",null,"分批多次渲染"),l.createElement("p",null,"既然瓶颈在渲染阶段，那分批多次渲染会不会更好？"),l.createElement("pre",null,l.createElement("code",{className:"language-html",dangerouslySetInnerHTML:{__html:'<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">const</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);\n    <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>;\n    <span class="hljs-keyword">const</span> once = <span class="hljs-number">20</span>;\n    <span class="hljs-keyword">const</span> times = total / once;\n    <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curIndex</span>) </span>{\n      <span class="hljs-keyword">if</span> (curIndex &lt; times) {\n        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n          <span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();\n          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; once; i++) {\n            <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);\n            li.innerText = curIndex + <span class="hljs-string">&#x27;:&#x27;</span> + i;\n            fragment.appendChild(li);\n          }\n          ul.appendChild(fragment);\n        }, <span class="hljs-number">0</span>);\n        loop(++curIndex);\n      }\n    }\n    loop(idx);\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n'}})),l.createElement("p",null,"这里单次渲染 20 条，分 5000 次渲染完成。因为",l.createElement("code",{dangerouslySetInnerHTML:{__html:"setTimeout"}}),"的回调函数会在下一次事件循环中执行，所以不会造成页面长时间空白。即 js 生成 20 条数据，浏览器渲染 20 条数据，然后再生成再渲染，避免了一次性大量渲染。"),l.createElement("p",null,l.createElement("img",{src:n(273).default,alt:"分批渲染"})),l.createElement("p",null,"可以看出渲染时间大大地缩短了"),l.createElement("p",null,"但是拖动滚动条还是会出现空白闪动的效果。这是因为",l.createElement("code",{dangerouslySetInnerHTML:{__html:"setTimeout"}}),"的延迟时间并不精确。"),l.createElement("h2",null,"requestAnimationFrame"),l.createElement("pre",null,l.createElement("code",{className:"language-html",dangerouslySetInnerHTML:{__html:'<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n    <span class="hljs-keyword">const</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);\n    <span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>;\n    <span class="hljs-keyword">const</span> once = <span class="hljs-number">20</span>;\n    <span class="hljs-keyword">const</span> times = total / once;\n    <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curIndex</span>) </span>{\n      <span class="hljs-keyword">if</span> (curIndex &lt; times) {\n        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function">() =&gt;</span> {\n          <span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();\n          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; once; i++) {\n            <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);\n            li.innerText = curIndex + <span class="hljs-string">&#x27;:&#x27;</span> + i;\n            fragment.appendChild(li);\n          }\n          ul.appendChild(fragment);\n          loop(++curIndex);\n        });\n      }\n    }\n    loop(idx);\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n'}})),l.createElement("p",null,"该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。这样就等于把确定执行时间的问题交给浏览器自身，开发者不必去考虑延迟时间的精确性问题。"),l.createElement("p",null,"关于重绘和回流：",l.createElement("strong",null,"当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流；当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘"),"。"),l.createElement("p",null,"简单地说，只有样式改变，就发生重绘，布局改变，就发生回流。可以说，回流必定重绘，重绘不一定回流。"),l.createElement("p",null,"以上 html 的执行过程就是：每一次重绘就生成 20 条数据，然后渲染 20 条数据。因为时间由浏览器自身控制，就不会造成空白闪现的效果。"))}},272:function(s,a,n){"use strict";n.r(a),a.default=n.p+"media/images/c08fdd78992419f5b34842e0bf36bbbe.png"},273:function(s,a,n){"use strict";n.r(a),a.default=n.p+"media/images/2502e578083bbf26c2c6f48fc5e1195e.png"}}]);
//# sourceMappingURL=11.7100a8fd75.js.map