(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{206:function(s,n,a){const l=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return l.createElement("section",{className:"markdown"},l.createElement("h1",null,"作用域"),l.createElement("ul",null,l.createElement("li",null,"解释 官方解释作用域：‘一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。’ 通俗地解释作用域：就是一块‘地盘’，一个代码所在的区域。JavaScript 中的作用域是静态的，在编写代码时就确定了。"),l.createElement("li",null,"作用 隔离变量，不同作用域下即使是同名变量也不会发生冲突。"),l.createElement("li",null,"分类")),l.createElement("ol",null,l.createElement("li",null,"全局作用域"),l.createElement("li",null,"函数作用域"),l.createElement("li",null,"块级作用域（ES6 新增）")),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">//全局作用域</span>\n<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">//函数foo的作用域</span>\n  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">//函数fn的作用域</span>\n    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;\n  }\n}\n<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {\n  <span class="hljs-comment">//ES6块级作用域</span>\n  <span class="hljs-keyword">let</span> a = <span class="hljs-number">4</span>;\n}\n'}})),l.createElement("ul",null,l.createElement("li",null,"作用域链 JavaScript 中查找变量的过程是沿着作用域链由内而外的查找，直至全局作用域。"),l.createElement("li",null,"习题")),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">//题1</span>\n<span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//作用域在函数定义时就已经确定了不改变</span>\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">f</span>) </span>{\n  <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;\n  f();\n}\nshow(fn); <span class="hljs-comment">//10</span>\n\n<span class="hljs-comment">//题2</span>\n<span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(fn);\n};\nfn(); <span class="hljs-comment">//输出fn函数</span>\n\n<span class="hljs-keyword">var</span> obj = {\n  <span class="hljs-attr">fn2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(fn);\n  }\n};\n\nobj.fn2();\n<span class="hljs-comment">//先在内部作用域找，然后去全局作用域找，找到fn函数并输出，</span>\n<span class="hljs-comment">//如果要找找obj.fn2应该console.log(this.fn2)</span>\n'}})))}}}]);
//# sourceMappingURL=43.987a4d95e8.js.map