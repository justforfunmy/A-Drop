(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{170:function(e,n,t){const a=t(0);e.exports=function(e){Object.keys(e).forEach((function(n){this[n]=e[n]}));return a.createElement("section",{className:"markdown"},a.createElement("h1",null,"css 动画保持最终状态"),a.createElement("pre",null,a.createElement("code",{className:"language-css",dangerouslySetInnerHTML:{__html:'<span class="hljs-selector-tag">animation-fill-mode</span> : <span class="hljs-selector-tag">none</span>  <span class="hljs-selector-tag">forwards</span>  <span class="hljs-selector-tag">backwards</span>  <span class="hljs-selector-tag">both</span>;\n'}})),a.createElement("p",null,a.createElement("code",{dangerouslySetInnerHTML:{__html:"none"}}),"：不改变默认行为。"),a.createElement("p",null,a.createElement("code",{dangerouslySetInnerHTML:{__html:"forwards"}})," ：当动画完成后，保持最后一个属性值。"),a.createElement("p",null,a.createElement("code",{dangerouslySetInnerHTML:{__html:"backwards"}}),"：在 ",a.createElement("code",{dangerouslySetInnerHTML:{__html:"animation-delay"}})," 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。"),a.createElement("p",null,a.createElement("code",{dangerouslySetInnerHTML:{__html:"both"}}),"：向前和向后填充模式都被应用。"))}}}]);
//# sourceMappingURL=17.4734598e17.js.map