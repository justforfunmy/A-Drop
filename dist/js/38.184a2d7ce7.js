(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{199:function(s,n,e){const a=e(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return a.createElement("section",{className:"markdown"},a.createElement("h1",null,"React Hooks 原理及实现"),a.createElement("p",null,"在开始讲 React Hooks 原理之前，先来看看 Hooks 的产生是为了解决哪些问题："),a.createElement("ul",null,a.createElement("li",null,"逻辑很难复用，在类组件的基础上用 HOC 或者 render props,这样会导致组件的层级很深。举个例子，当",a.createElement("code",{dangerouslySetInnerHTML:{__html:"react-router"}}),"+",a.createElement("code",{dangerouslySetInnerHTML:{__html:"redux"}}),"结合使用时，可能会出现这样的组件：")),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(<span class="hljs-comment">/*...*/</span>)(WidthRouter(React.memo(myComponent)));\n'}})),a.createElement("ul",null,a.createElement("li",null,a.createElement("p",null,"组件会很大，很多代码必须写在类中")),a.createElement("li",null,a.createElement("p",null,"类组件中的 this 指向容易出错")),a.createElement("li",null,a.createElement("p",null,"class 代码对于打包工具来说，很难被压缩"))),a.createElement("h2",null,"useState"),a.createElement("p",null,"最简单的 useState 的使用方法是这样的："),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">const</span> Demo = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">2</span>);\n  <span class="hljs-keyword">return</span> (\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count:{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n  );\n};\n'}})),a.createElement("p",null,"这里用了 useState 来维护 count 这个状态值。"),a.createElement("p",null,"useState 的原理其实很简单，组件是函数，组件的更新就是重新执行一次函数，而在执行时要确保状态值是最新的。"),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">//用来保存上一次的值</span>\n<span class="hljs-keyword">let</span> memorizedState;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>(<span class="hljs-params">initialState</span>) </span>{\n  <span class="hljs-comment">//获取当前的组件，这里就是简单的从全局获取，有更好的实现，不必关注这里</span>\n  <span class="hljs-keyword">const</span> comp = <span class="hljs-built_in">window</span>.currentComponent;\n  <span class="hljs-comment">//如果上一次没有值，也就是第一次渲染，就赋值初始值</span>\n  memorizedState = memorizedState || initialState;\n  <span class="hljs-comment">//更新状态函数</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setState</span>(<span class="hljs-params">stateChange</span>) </span>{\n    <span class="hljs-comment">//状态更新</span>\n    memorizedState = stateChange;\n    <span class="hljs-comment">//重新渲染组件</span>\n    renderComponent(comp);\n  }\n  <span class="hljs-comment">//把最新的状态值和更新函数以数组的形式返回</span>\n  <span class="hljs-keyword">return</span> [memorizedState, setState];\n}\n'}})),a.createElement("p",null,"基本功能已经完成，但这里会有一个问题，因为全局只有一个",a.createElement("code",{dangerouslySetInnerHTML:{__html:"memorizedState"}}),"，当有多个",a.createElement("code",{dangerouslySetInnerHTML:{__html:"useState"}}),"时，后面的会把前面的覆盖掉。用数组可以解决："),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">const</span> memorizedState = [];\n<span class="hljs-keyword">let</span> cursor = <span class="hljs-number">0</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>(<span class="hljs-params">initialState</span>) </span>{\n  <span class="hljs-keyword">const</span> comp = <span class="hljs-built_in">window</span>.currentComponent;\n  <span class="hljs-comment">// 一一对应的state</span>\n  memorizedState[cursor] = memorizedState[cursor] || initialState;\n  <span class="hljs-comment">// 用于更新时知道需要的更新的下标值</span>\n  <span class="hljs-keyword">const</span> currentCursor = cursor;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setState</span>(<span class="hljs-params">stateChange</span>) </span>{\n    <span class="hljs-comment">//更新指定的state</span>\n    memorizedState[currentCursor] = stateChange;\n    <span class="hljs-comment">//更新完之后重置cursor，以确保下一次函数执行按顺序从头开始取值</span>\n    cursor = <span class="hljs-number">0</span>;\n    renderComponent(comp);\n  }\n  <span class="hljs-comment">// 返回state并cursor加一</span>\n  <span class="hljs-keyword">return</span> [memorizedState[cursor++], setState];\n}\n'}})),a.createElement("p",null,"这也就是为什么只能在函数的最外层调用 useState,而不能在循环，条件判断中使用。",a.createElement("strong",null,"因为 memorizedState 数组是按 hook 定义的顺序赖存放数据的，如果顺序有变，数组本身并不会感知")),a.createElement("h2",null,"useEffect"),a.createElement("p",null,"useEffect 的基本用法是这样的："),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'useEffect(<span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;123&#x27;</span>);\n}, [count]);\n'}})),a.createElement("p",null,"useEffect 有以下特点："),a.createElement("ol",null,a.createElement("li",null,a.createElement("p",null,"有两个参数 callback 和 dependencies 数组")),a.createElement("li",null,a.createElement("p",null,"如果 dependencies 不存在，那么 callback 每次 render 都会执行")),a.createElement("li",null,a.createElement("p",null,"如果 dependencies 存在，只有当它发生了变化， callback 才会执行"))),a.createElement("p",null,"基于这些特点来实现一个 useEffect："),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEffect</span>(<span class="hljs-params">callback, depArray</span>) </span>{\n  <span class="hljs-comment">//判断当前depArray是否存在</span>\n  <span class="hljs-keyword">const</span> hasNoDeps = !depArray;\n  <span class="hljs-comment">// 指定的依赖</span>\n  <span class="hljs-keyword">const</span> deps = memorizedState[cursor];\n  <span class="hljs-comment">// 判断依赖是否改变</span>\n  <span class="hljs-keyword">const</span> hasDepChanged = deps ? !depArray.every(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> deps[i] === el) : <span class="hljs-literal">true</span>;\n  <span class="hljs-comment">// 如果没有依赖货值依赖改变则执行回调函数，并保存当前依赖值</span>\n  <span class="hljs-keyword">if</span> (hasNoDeps || hasDepChanged) {\n    memorizedState[cursor] = depArray;\n    callback();\n  }\n  cursor++;\n}\n'}})),a.createElement("p",null,"我们可以发现，当第二个参数是空数组时，依赖一直不会变化，回调函数只会执行一次，就相当于生命周期函数",a.createElement("code",{dangerouslySetInnerHTML:{__html:"componentDidMount"}})),a.createElement("h2",null,"单独的 memorizedState"),a.createElement("p",null,"以上的实现还有一个问题，就是多个组件共用了一个 memorizedState,所以单个组件内没有问题，多个组件就会导致状态混乱。可以将 memorizedState 挂载到每个组件的实例上去，单独维护。"),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">//react component</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>{\n  <span class="hljs-keyword">constructor</span>(props) {\n    <span class="hljs-built_in">this</span>.props = props;\n    <span class="hljs-built_in">this</span>.memorizedState = [];\n    <span class="hljs-built_in">this</span>.cursor = <span class="hljs-number">0</span>;\n  }\n\n  render() {}\n}\n'}})),a.createElement("p",null,"重新修改下 hooks 的实现"),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useState</span>(<span class="hljs-params">initialState</span>) </span>{\n  <span class="hljs-keyword">const</span> comp = <span class="hljs-built_in">window</span>.currentComponent;\n  <span class="hljs-comment">//获取单独的状态集合</span>\n  <span class="hljs-keyword">const</span> { memorizedState, cursor } = comp;\n  memorizedState[cursor] = memorizedState[cursor] || initialState;\n  <span class="hljs-keyword">const</span> currentCursor = cursor;\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setState</span>(<span class="hljs-params">stateChange</span>) </span>{\n    memorizedState[currentCursor] = stateChange;\n    renderComponent(comp);\n  }\n  <span class="hljs-keyword">return</span> [memorizedState[comp.cursor++], setState];\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useEffect</span>(<span class="hljs-params">callback, depArray</span>) </span>{\n  <span class="hljs-keyword">const</span> comp = <span class="hljs-built_in">window</span>.currentComponent;\n  <span class="hljs-keyword">const</span> { memorizedState, cursor } = comp;\n  <span class="hljs-keyword">const</span> hasNoDeps = !depArray;\n  <span class="hljs-keyword">const</span> deps = memorizedState[cursor];\n  <span class="hljs-keyword">const</span> hasDepChanged = deps ? !depArray.every(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> deps[i] === el) : <span class="hljs-literal">true</span>;\n  <span class="hljs-keyword">if</span> (hasNoDeps || hasDepChanged) {\n    memorizedState[cursor] = depArray;\n    callback();\n  }\n  comp.cursor++;\n}\n'}})),a.createElement("p",null,"此处需要在 renderComponent 函数执行时将组件的 cursor 置零，以保证渲染时从头开始执行 hooks"),a.createElement("pre",null,a.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderComponent</span>(<span class="hljs-params">component</span>) </span>{\n  <span class="hljs-comment">// hooks的cursor置零，按顺序从头执行hook</span>\n  component.cursor = <span class="hljs-number">0</span>;\n  <span class="hljs-comment">//...</span>\n}\n'}})),a.createElement("p",null,"这样，hooks 基本实现了"),a.createElement("p",null,"参考文章："),a.createElement("p",null,a.createElement("a",{href:"https://github.com/brickspert/blog/issues/26"},"React Hooks 原理"),a.createElement("a",{href:"https://segmentfault.com/a/1190000020832946"},"深入 React hooks — 原理 & 实现"),a.createElement("a",{href:"https://juejin.im/post/6844903704437456909"},"阅读源码后，来讲讲 React Hooks 是怎么实现的")))}}}]);
//# sourceMappingURL=38.184a2d7ce7.js.map