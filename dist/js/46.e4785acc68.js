(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{190:function(e,s,n){const l=n(0);e.exports=function(e){Object.keys(e).forEach((function(s){this[s]=e[s]}));return l.createElement("section",{className:"markdown"},l.createElement("h1",null,"根据",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promises/A+"}}),"规范实现",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}})),l.createElement("h2",null,"创建",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}})),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>{\n    ...\n})\n'}})),l.createElement("p",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}}),"构造器接收一个被称为执行器的函数，该函数会被传递两个函数作为参数，一个是成功时调用的函数",l.createElement("code",{dangerouslySetInnerHTML:{__html:"resolve"}}),",一个是失败是调用的函数",l.createElement("code",{dangerouslySetInnerHTML:{__html:"reject"}}),"。"),l.createElement("h2",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"中的术语"),l.createElement("ul",null,l.createElement("li",null,"解决（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"fulfill"}}),"）：指一个 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}})," 成功时进行的一系列操作，如状态的改变、回调的执行。也就是",l.createElement("code",{dangerouslySetInnerHTML:{__html:"resolve"}})),l.createElement("li",null,"拒绝（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"reject"}}),"）：指一个 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}})," 失败时进行的一系列操作。"),l.createElement("li",null,"终值（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"eventual value"}}),"）：所谓终值，指的是 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}})," 被解决时传递给解决回调的值。"),l.createElement("li",null,"据因（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"reason"}}),"）：也就是拒绝原因，指在 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}})," 被拒绝时传递给拒绝回调的值。")),l.createElement("h2",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"的状态"),l.createElement("p",null,"一个 Promise 的当前状态必须为以下三种状态中的一种：",l.createElement("strong",null,"等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）"),"。",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"的初始状态为",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Pending"}}),",并且只会进入执行态（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Fulfilled"}}),"）或者拒绝态（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Rejected"}}),"）,之后不能更改状态，即（",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Pending -&gt; Fulfilled"}})," 或者 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Pending -&gt; Rejected"}}),"）"),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myPromise</span>(<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;\n  self.value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">//promise的值</span>\n  self.reason = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">//promise的拒因</span>\n  self.state = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">//promise的状态</span>\n  <span class="hljs-comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span>\n  self.onResolvedCallback = [];\n  <span class="hljs-comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span>\n  self.onRejectedCallback = [];\n\n  <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {\n    <span class="hljs-comment">//成功时的操作</span>\n  };\n\n  <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {\n    <span class="hljs-comment">//失败时的操作</span>\n  };\n\n  <span class="hljs-comment">//executor是一个立即执行函数，可能会出错，</span>\n  <span class="hljs-comment">//这里用trycatch来捕获错误，并传递给reject函数</span>\n  <span class="hljs-keyword">try</span> {\n    executor(resolve, reject);\n  } <span class="hljs-keyword">catch</span> (error) {\n    reject(error);\n  }\n}\n'}})),l.createElement("p",null,"这样就把",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"的主体结构给完成了，接下来要实现",l.createElement("code",{dangerouslySetInnerHTML:{__html:"resolve"}}),"和",l.createElement("code",{dangerouslySetInnerHTML:{__html:"reject"}}),"方法"),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{\n  <span class="hljs-comment">//判断状态是否为执行态</span>\n  <span class="hljs-keyword">if</span> (self.state === <span class="hljs-string">&#x27;pending&#x27;</span>) {\n    <span class="hljs-comment">//更新状态为完成态</span>\n    self.state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;\n    <span class="hljs-comment">//更新Promise的值</span>\n    self.value = res;\n    <span class="hljs-comment">//依次调用完成时的回调函数，并将值传递过去</span>\n    self.onResolveCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> {\n      fn(res);\n    });\n  }\n};\n<span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{\n  <span class="hljs-comment">//判断状态是否为执行态</span>\n  <span class="hljs-keyword">if</span> (self.state === <span class="hljs-string">&#x27;pending&#x27;</span>) {\n    <span class="hljs-comment">//更新状态为拒绝态</span>\n    self.state = <span class="hljs-string">&#x27;rejected&#x27;</span>;\n    <span class="hljs-comment">//更新Promise的拒因</span>\n    self.reason = err;\n    <span class="hljs-comment">//依次调用拒绝时的回调函数，并将拒因传递过去</span>\n    self.onRejectedCallbacks.forEach(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> {\n      fn(err);\n    });\n  }\n};\n'}})),l.createElement("h2",null,"Then 方法"),l.createElement("p",null,"一个 promise 必须提供一个 ",l.createElement("code",{dangerouslySetInnerHTML:{__html:"then"}})," 方法以访问其当前值、终值和据因。"),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:"promise.then(onFulfilled, onRejected);\n"}})),l.createElement("ol",null,l.createElement("li",null,"如果",l.createElement("code",{dangerouslySetInnerHTML:{__html:"onFulfilled"}}),"和",l.createElement("code",{dangerouslySetInnerHTML:{__html:"onRejected"}}),"不是函数，必须忽略"),l.createElement("li",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"onFulfilled"}}),"仅在",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"成功时调用，",l.createElement("code",{dangerouslySetInnerHTML:{__html:"value"}}),"是第一个参数 ，仅调用一次"),l.createElement("li",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"onRejected"}}),"仅在",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"被拒绝时调用，",l.createElement("code",{dangerouslySetInnerHTML:{__html:"reason"}}),"是第一个参数，仅调用一次"),l.createElement("li",null,l.createElement("code",{dangerouslySetInnerHTML:{__html:"then"}}),"方法返回一个",l.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}))),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'myPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>{\n  <span class="hljs-comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理</span>\n  onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{};\n  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{};\n\n  <span class="hljs-keyword">if</span> (self.state === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      <span class="hljs-keyword">let</span> result = onFulfilled(self.value);\n      <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> myPromise) {\n        <span class="hljs-comment">//如果resolve的返回值是一个Promise，直接取它的结果</span>\n        result.then(resolve, reject);\n      }\n      resolve(result);\n    });\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.state === <span class="hljs-string">&#x27;rejected&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      <span class="hljs-keyword">let</span> result = onRejected(self.reason);\n      <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> myPromise) {\n        result.then(resolve, reject);\n      }\n      reject(result);\n    });\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.state === <span class="hljs-string">&#x27;pending&#x27;</span>) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> myPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      self.onResolveCallbacks.push(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-keyword">let</span> result = onFulfilled(self.value);\n        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> myPromise) {\n          result.then(resolve, reject);\n        }\n        resolve(result);\n      });\n      self.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-keyword">let</span> result = onRejected(self.reason);\n        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> myPromise) {\n          result.then(resolve, reject);\n        }\n        reject(result);\n      });\n    });\n  }\n};\n'}})))}}}]);
//# sourceMappingURL=46.e4785acc68.js.map