(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{190:function(s,n,a){const e=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return e.createElement("section",{className:"markdown"},e.createElement("h1",null,"异步 setState"),e.createElement("p",null,"react 对 setState 做了相应优化，使得每次 setState 后并不是同步去更新视图，而是在合并了多次更改后在合适的时间一次性更新，所以说 setState 是异步的"),e.createElement("h2",null,"队列"),e.createElement("p",null,"队列是一种先进先出的数据结构，可以用数组的 shift 操作实现队列弹出"),e.createElement("p",null,"首先，要维护一个状态队列，将每次状态的更改加入队列，而不是立即执行渲染组件;"),e.createElement("p",null,"然后，要维护一个组件队列，将需要更新的组件加入队列"),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">/**\n *入队\n * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>state 组件状态\n * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>component 组件实例\n * <span class="hljs-doctag">@param <span class="hljs-type">{*}</span> </span>callbak 回调函数\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueSetState</span>(<span class="hljs-params">state, component, callback</span>) </span>{\n  queue.push({ state, component, callback });\n  <span class="hljs-comment">// 如果待渲染的组件队列中不含有该组件，则组件队列中加入该组件</span>\n  <span class="hljs-keyword">if</span> (!renderQueue.some(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item === component)) {\n    enqueueRender(component);\n  }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueRender</span>(<span class="hljs-params">component</span>) </span>{\n  renderQueue.push(component);\n}\n'}})),e.createElement("h2",null,"队列清空"),e.createElement("p",null,"按照先进先出的规则遍历状态队列，将组件的状态依次合并，并将最终状态赋予组件，如果有回调函数，则在每次合并后执行同步回调。"),e.createElement("p",null,"遍历完状态后，每个需要更新的组件的状态都是合并之后的最终状态，之后再循环遍历组件队列，依次渲染组件，这就达到了将多次更改合并成一次更新的效果，提升了性能"),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushQueue</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">let</span> stateItem;\n  <span class="hljs-keyword">let</span> componentItem;\n  <span class="hljs-keyword">let</span> nextState;\n  <span class="hljs-comment">// 从头部开始遍历状态队列，每遍历一个删除一个</span>\n  <span class="hljs-keyword">while</span> ((stateItem = queue.shift())) {\n    <span class="hljs-keyword">const</span> { state, component, callback } = stateItem;\n    <span class="hljs-comment">// 组件原先没有state，则赋值新的state</span>\n    <span class="hljs-keyword">if</span> (!component.state) {\n      nextState = { ...state };\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-comment">// 组件原先有state，则浅合并</span>\n      nextState = { ...component.state, ...state };\n    }\n    <span class="hljs-comment">// 将组件赋予新的state</span>\n    component.state = nextState;\n    <span class="hljs-comment">// 如果有回调函数，则同步执行回调函数,并绑定组件实例</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {\n      callback.call(component);\n    }\n  }\n\n  <span class="hljs-comment">// 遍历待渲染组件，此时组件的状态可能是多次合并的结果</span>\n  <span class="hljs-keyword">while</span> ((componentItem = renderQueue.shift())) {\n    renderComponent(componentItem);\n  }\n}\n'}})),e.createElement("h2",null,"合适的更新时间"),e.createElement("p",null,"这里主要用到了 JavaScript 的事件循环模型，让浏览器在空闲的时间执行"),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>{\n    <span class="hljs-comment">// 当浏览器空闲时，执行清空队列操作</span>\n    requestIdleCallback(fn);\n  };\n}\n'}})),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueueSetState</span>(<span class="hljs-params">state, component, callback</span>) </span>{\n  <span class="hljs-comment">// 如果queue的长度是0，也就是在上次flush执行之后第一次往队列里添加</span>\n  <span class="hljs-keyword">if</span> (queue.length === <span class="hljs-number">0</span>) {\n    defer()(flushQueue);\n  }\n  queue.push({ state, component, callback });\n  <span class="hljs-comment">// 如果待渲染的组件队列中不含有该组件，则组件队列中加入该组件</span>\n  <span class="hljs-keyword">if</span> (!renderQueue.some(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item === component)) {\n    enqueueRender(component);\n  }\n}\n'}})))}}}]);
//# sourceMappingURL=29.434471bf47.js.map