(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{183:function(s,n,a){const e=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return e.createElement("section",{className:"markdown"},e.createElement("h1",null,"call，apply"),e.createElement("p",null,"首先，来看下面这一个例子："),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">let</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;king&#x27;</span>,\n  <span class="hljs-attr">greet</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello,&#x27;</span> + <span class="hljs-built_in">this</span>.name);\n  }\n};\n<span class="hljs-comment">//hello,king</span>\nperson.greet();\n'}})),e.createElement("p",null,"现在，有另一个对象 person2，",e.createElement("code",{dangerouslySetInnerHTML:{__html:"let person2={name:'sara'}"}}),"。如果他也想调用 greet 方法，那么可以这么实现：为 person2 添加方法，指向 person 的 greet 方法，即",e.createElement("code",{dangerouslySetInnerHTML:{__html:"person2.greet=person.greet"}}),"。然而，person2 仅仅是临时需要调用 greet 方法，这样重新为 person2 定义 greet 方法显得不是很有必要，这时候就需要 call 或者 apply 出场了。 利用 call，apply 可以这么实现："),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'person.greet.call(person2); <span class="hljs-comment">//hello,sara</span>\nperson.greet.apply(person2); <span class="hljs-comment">//hello,sara</span>\n'}})),e.createElement("p",null,"其实 ",e.createElement("code",{dangerouslySetInnerHTML:{__html:"call"}})," 和 ",e.createElement("code",{dangerouslySetInnerHTML:{__html:"apply"}})," 的用处是一样的，就是让对象临时调用本不属于自己的方法，而不用为自身添加该方法。两者的不同在于调用的时候传参的形式，",e.createElement("code",{dangerouslySetInnerHTML:{__html:"call"}})," 以单个参数依次传入，",e.createElement("code",{dangerouslySetInnerHTML:{__html:"apply"}})," 以数组的方式传入，以上 greet 方法没有形参，所以不能体现出不同。以上例子稍作修改即可体现："),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">let</span> person = {\n  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;king&#x27;</span>,\n  <span class="hljs-attr">greet</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{\n    <span class="hljs-built_in">console</span>.log(str, <span class="hljs-built_in">this</span>.name);\n  }\n};\n<span class="hljs-keyword">let</span> person2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sara&#x27;</span> };\nperson.greet.call(person2, <span class="hljs-string">&#x27;hi&#x27;</span>); <span class="hljs-comment">//hi,sara</span>\nperson.greet.apply(person2, [<span class="hljs-string">&#x27;hi&#x27;</span>]); <span class="hljs-comment">//hi,sara</span>\n'}})),e.createElement("h2",null,"模拟实现原理"),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>{\n  <span class="hljs-keyword">let</span> ctx = context || <span class="hljs-built_in">window</span>;\n  ctx.fn = <span class="hljs-built_in">this</span>; <span class="hljs-comment">//此处this指向调用call2函数的函数对象，例子中是peoson.greet</span>\n  <span class="hljs-comment">//传参，call2函数的第一个参数是需要调用函数的对象，函数参数从第二个开始</span>\n  <span class="hljs-keyword">let</span> args = [];\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) {\n    args.push(<span class="hljs-built_in">arguments</span>[i]);\n  }\n  ctx.fn(...args); <span class="hljs-comment">//es6扩展运算符，相当于ctx.fn(args[0],args[1],...args[args.length-1])</span>\n  <span class="hljs-keyword">delete</span> ctx.fn; <span class="hljs-comment">//用完删除，释放空间</span>\n};\nperson.greet.call2(person2, <span class="hljs-string">&#x27;hi&#x27;</span>); <span class="hljs-comment">//hi,sara</span>\n'}})),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-built_in">Function</span>.prototype.apply2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) </span>{\n  <span class="hljs-keyword">let</span> ctx = context || <span class="hljs-built_in">window</span>;\n  ctx.fn = <span class="hljs-built_in">this</span>;\n  <span class="hljs-comment">//判断是否带参数，以及参数是否为数组</span>\n  <span class="hljs-keyword">if</span> (!arr) {\n    ctx.fn();\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">if</span> (!arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {\n      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;params must be array&#x27;</span>);\n    } <span class="hljs-keyword">else</span> {\n      ctx.fn(...arr);\n    }\n  }\n  <span class="hljs-keyword">delete</span> ctx.fn;\n};\nperson.greet.apply2(person2, [<span class="hljs-string">&#x27;hi&#x27;</span>]); <span class="hljs-comment">//hi,sara</span>\n'}})),e.createElement("p",null,"简单的说，call,apply 可以让一个函数临时成为对象的方法，即让函数中的 this 可以指向该对象。"))}}}]);
//# sourceMappingURL=34.e6672db76c.js.map