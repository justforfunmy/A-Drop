(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{169:function(s,n,a){const e=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return e.createElement("section",{className:"markdown"},e.createElement("h1",null,"JS 异步编程"),e.createElement("p",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"Javascript"}}),'语言的执行环境是"单线程"。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。如果某个任务耗时过长，就会导致后续的任务一直等着，拖延了整个程序的执行，常见的就是浏览器无响应（假死）。为了解决这个问题，',e.createElement("code",{dangerouslySetInnerHTML:{__html:"Javascript"}}),"出现了异步编程的模式。通俗地讲，异步任务就是当执行到某个耗时很长的任务时，后续任务不用等待异步任务执行完毕再执行，等到异步任务完成，浏览器再对异步任务作出响应，即异步任务不会阻塞后续任务。异步任务最好的例子就是",e.createElement("code",{dangerouslySetInnerHTML:{__html:"Ajax"}}),"操作。"),e.createElement("h2",null,"异步编程方案"),e.createElement("ul",null,e.createElement("li",null,"回调函数")),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'ajax(url, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">//todo...</span>\n});\n'}})),e.createElement("p",null,"简单，容易实现，但多个回调函数嵌套会使得结构复杂，难以维护。"),e.createElement("ul",null,e.createElement("li",null,"事件监听")),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div&#x27;</span>);\ndiv.addEventListener(<span class="hljs-string">&#x27;cilck&#x27;</span>, <span class="hljs-function">() =&gt;</span> {\n  <span class="hljs-comment">//todo...</span>\n});\n'}})),e.createElement("p",null,"事件驱动型会使得程序的运行流程变得不清晰"),e.createElement("ul",null,e.createElement("li",null,"发布/订阅")),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">O</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">this</span>.subs = [];\n}\nO.prototype.publish = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{\n  <span class="hljs-built_in">this</span>.subs.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {\n    <span class="hljs-keyword">if</span> (item.event === event) {\n      item.callback();\n    }\n  });\n};\nO.prototype.subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event, callback</span>) </span>{\n  <span class="hljs-built_in">this</span>.subs.push({\n    event,\n    callback\n  });\n};\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;f2 start&#x27;</span>);\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-comment">//todo...</span>\n    origin.publish(<span class="hljs-string">&#x27;done&#x27;</span>);\n  }, <span class="hljs-number">1000</span>);\n}\n<span class="hljs-keyword">const</span> origin = <span class="hljs-keyword">new</span> O();\norigin.subscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);\nf1();\n'}})),e.createElement("p",null,"我们假设存在信息中心 origin,f2 向信息中心订阅'done'信号，当 f1 执行完之后，发布'done'信号,从而引发 f2 的执行。"),e.createElement("ul",null,e.createElement("li",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}))),e.createElement("p",null,e.createElement("a",{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API"},"Fetch"),"就是使用",e.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"的例子"),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'fetch(<span class="hljs-string">&#x27;./data.json&#x27;</span>)\n  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {\n    <span class="hljs-keyword">return</span> res.json();\n  })\n  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(res);\n  });\n'}})),e.createElement("p",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}),"通过链式调用解决了回调地域的问题，也能很好地捕获错误，细节参见我的博客",e.createElement("a",{href:"https://github.com/justforfunmy/Notebook/blob/master/md/JavaScript/promiseA+.md"},"根据",e.createElement("code",{dangerouslySetInnerHTML:{__html:"Promises/A+"}}),"规范实现",e.createElement("code",{dangerouslySetInnerHTML:{__html:"Promise"}}))),e.createElement("ul",null,e.createElement("li",null,"生成器 Generators/ yield")),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;f1 done&#x27;</span>);\n  }, <span class="hljs-number">1000</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;f2 done&#x27;</span>);\n  }, <span class="hljs-number">2000</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f3</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;f3 done&#x27;</span>);\n  }, <span class="hljs-number">3000</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">controller</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">yield</span> f1();\n  <span class="hljs-keyword">yield</span> f2();\n  <span class="hljs-keyword">yield</span> f3();\n}\n\n<span class="hljs-keyword">const</span> c = controller();\nc.next(); <span class="hljs-comment">//f1 done</span>\nc.next(); <span class="hljs-comment">//f2 done</span>\nc.next(); <span class="hljs-comment">//f3 done</span>\n'}})),e.createElement("p",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"Generator"}}),"可以控制函数的执行，",e.createElement("code",{dangerouslySetInnerHTML:{__html:"yield"}}),"暂停，",e.createElement("code",{dangerouslySetInnerHTML:{__html:"next"}}),"启动"),e.createElement("ul",null,e.createElement("li",null,"async/await")),e.createElement("p",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"async/await"}}),"其实是基于",e.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}}),"实现的语法糖，其真正的魔力在于能使得异步代码看起来像同步代码。"),e.createElement("p",null,e.createElement("strong",null,e.createElement("code",{dangerouslySetInnerHTML:{__html:"async"}}),"函数执行会返回一个",e.createElement("code",{dangerouslySetInnerHTML:{__html:"promise"}}))),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">params</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n}\n\n<span class="hljs-built_in">console</span>.log(f()); <span class="hljs-comment">//Promise {&lt;resolved&gt;: 1}</span>\n'}})),e.createElement("p",null,"实现一个读取文件的 async 函数："),e.createElement("pre",null,e.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">file</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    fs.readFile(file, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {\n      <span class="hljs-keyword">if</span> (err) {\n        reject(err);\n      } <span class="hljs-keyword">else</span> {\n        resolve(data);\n      }\n    });\n  });\n}\n\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readResult</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">const</span> r1 = <span class="hljs-keyword">await</span> read(<span class="hljs-string">&#x27;./data.json&#x27;</span>); <span class="hljs-comment">//await后跟一个promise实例</span>\n    <span class="hljs-built_in">console</span>.log(r1);\n  } <span class="hljs-keyword">catch</span> (error) {\n    <span class="hljs-built_in">console</span>.log(error);\n  }\n}\n\nreadResult();\n'}})))}}}]);