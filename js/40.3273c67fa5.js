(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{182:function(s,n,a){const l=a(0);s.exports=function(s){Object.keys(s).forEach((function(n){this[n]=s[n]}));return l.createElement("section",{className:"markdown"},l.createElement("h2",null,"防抖"),l.createElement("p",null,"在前端开发中，有些事件会持续触发，如 scroll，resize 事件，如果不停地执行处理函数，则会大大地消耗浏览器性能。这时就需要防抖函数来减少执行函数的频率。"),l.createElement("p",null,l.createElement("strong",null,"所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。")),l.createElement("p",null,"防抖函数的原理是：设定一个延时器，在 n 秒内多次触发事件并不执行函数，而是在每次触发后都重置延时器，将函数延后执行， 只有当 n 秒内不再触发事件，函数才会执行。以 scroll 事件为例，当我们滚动页面时，会不停地触发 scroll 事件，但每次触发事件， 并不执行函数，而是重置延时器，只有当 1 秒内不触发事件才会执行函数"),l.createElement("p",null,"实现："),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, timeout</span>) </span>{\n  <span class="hljs-comment">//存储延时器</span>\n  <span class="hljs-keyword">let</span> timer;\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">if</span> (timer !== <span class="hljs-literal">null</span>) {\n      <span class="hljs-comment">//防抖函数的代码使用这两行代码来获取 this 和 参数，</span>\n      <span class="hljs-comment">//是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</span>\n      <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;\n      <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;\n      <span class="hljs-comment">//当再次触发事件时，如果有延时器存在，就清除当前延时器</span>\n      <span class="hljs-built_in">clearTimeout</span>(timer);\n      <span class="hljs-comment">//重置延时器，即再延迟调用事件处理函数，</span>\n      <span class="hljs-comment">//只有当timeout时间内不再触发事件，才会执行函数</span>\n      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n        <span class="hljs-comment">//使得this不变</span>\n        fn.apply(context, args);\n      }, timeout);\n    }\n  };\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.random());\n}\n<span class="hljs-built_in">window</span>.onscroll = debounce(handle, <span class="hljs-number">1000</span>);\n'}})),l.createElement("h2",null,"节流"),l.createElement("p",null,"类似于防抖，",l.createElement("strong",null,"节流是在一段时间内只允许函数执行一次"),"，实现方法可以是时间戳法和定时器法。 实现："),l.createElement("pre",null,l.createElement("code",{className:"language-js",dangerouslySetInnerHTML:{__html:'<span class="hljs-comment">//时间戳</span>\n<span class="hljs-comment">/* 1.先记录第一次触发事件的时间prev，\n    2.当第二次触发事件时，记录时间now，\n    3.判断两次时间间隔是否大于设定的时间，如果小于就不执行函数，\n\t\t等待下一次触发事件，如果大于就执行函数，并将时间轴后移，\n\t\t即把prev的值改为当前时间\n    4.回到第一步反复执行 \n    特点：第一次触发事件不执行函数，之后不管触发多少次事件，\n\t\t每n秒执行一次函数，最后一次触发事件不会执行*/</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>{\n  <span class="hljs-keyword">let</span> prev = <span class="hljs-built_in">Date</span>.now();\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;\n    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;\n    <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();\n    <span class="hljs-keyword">if</span> (now - prev &gt;= wait) {\n      fn.apply(context, args);\n      prev = <span class="hljs-built_in">Date</span>.now();\n    }\n  };\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.random());\n}\n\n<span class="hljs-keyword">let</span> ipt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ipt&#x27;</span>);\nipt.oninput = throttle(handle, <span class="hljs-number">3000</span>);\n\n<span class="hljs-comment">//定时器</span>\n<span class="hljs-comment">/* \n    1. 第一次触发事件，设置延时器延时n秒执行函数\n    2.第二次触发事件，如果原延时器存在，则不执行函数，等待延时器，\n\t\t如果不存在，则设置延时器延时n秒执行函数\n    3.延时器到时间执行函数，并重置延时器为null\n    4.重复第一步\n    特点：第一次触发事件会延时n秒执行函数，最后一次触发事件也会延时n秒执行函数*/</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span>(<span class="hljs-params">fn, wait</span>) </span>{\n  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;\n    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;\n    <span class="hljs-keyword">if</span> (!timer) {\n      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {\n        fn.apply(context, args);\n        timer = <span class="hljs-literal">null</span>;\n      }, wait);\n    }\n  };\n}\n<span class="hljs-keyword">let</span> ipt2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ipt2&#x27;</span>);\nipt2.oninput = throttle1(handle, <span class="hljs-number">3000</span>);\n'}})))}}}]);
//# sourceMappingURL=40.3273c67fa5.js.map